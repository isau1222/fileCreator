# Цель

Более тесная интеграция Vue с Sails. Роутинг без перезагрузки с пререндерингом
на сервере и человеческими URL.

# Рассуждение

1. Мы используем клиентскую шаблонизацию и клиентский роутер,
   поэтому чтобы избежать дублирования кода, мы не будем использовать
   контроллеры, шаблонизацию и роутер sails для страниц приложения,
   а будем использовать их только для API. Но отказываясь от контроллеров,
   мы также отказываемся от постраничных политик и responses. Также,
   используя клиентский роутер, мы теряем возможность указывать статус коды.
2. Чтобы сохранить статус коды и постраничные политики, нужно полноценное SSR,
   с переносом соответствующей логики в клиетский код и возможностью определить
   результат на этапе SSR. Это также предоставит возможности для SEO
   (что потребует механизма управления head в рантайме) и кеширования HTML.

# Ограничения

1. SSR требует префетчинга данных, что требует аутентификации/авторизации
   на стороне сервера. Это ограничивает возможные стратегии
   аутентификации/авторизации (например через кроссдоменные куки).
2. Поскольку не существуют адекватного способа передать локальное состояние
   инстансов с сервера на клиент, имеет смысл все важное состояние
   в процессе префетчинга сохранять в store.
3. Поскольку асинхронные действия в процессе пререндеринга отследить невозможно
   (@TODO: аргументировать), использовать их стоит осторожно.
4. Поскольку инстансы в процессе пререндеринга проходят упрощенный жизненный
   цикл (@TODO: аргументировать), не стоит полагаться на хуки для манипуляции
   состоянием, важным для пререндеринга.
5. Поскольку один и тот же код будет исполняться на клиенте и на сервере,
   код, который не расчитан на такое (читай jQuery плагины, завязанные на DOM
   библиотеки, возможно D3) невозможно пререндерить, и он должен быть изолирован
   с помощью проверки окружения и условных require.
6. Поскольку html может отдаваться с разных адресов, ссылки на ассеты
   (скрипты, стили, изображения) должны быть либо абсолютные, либо
   генерироваться при пререндеринге и в рантайме.

# Нерешенные проблемы

1. Если в процессе пререндеринга произошла рантайм ошибка, то стек ошибки
   будет неинформативный, поскольку не учитывается sourcemap. Можно попробовать
   "перевести" стек вручную.
2. В development режиме сервер будет отвечать ошибкой в процессе сборки и
   при неуспешной сборке. Можно исправить, обернув в промисы, но это несколько
   усложнит код, и возможно не стоит того.

# Дополнительные функции

1. Сборка стилей (возможно, достаточно будет SFC).
2. Поддержка bower (как css так и js).
3. ES6 language features. Вкусно, и не должно составить больших трудностей.
4. SFC (single file components). Упрощает работу со стилями и шаблонами,
   позволяет использовать облегченный рантайм (меньше размер файла,
   выше производительность), позволяет использовать готовые компоненты.
   Затрудняет сборку (нужно вытаскивать css из js). Затрудняет использование
   готовых инструментов, расчитанных на работу с голыми css и js.
5. Hot-reload. Упрощает разработку, позволяя обновлять шаблоны и стили
   без перезагрузки страницы. Требует SFC. Усложняет код сервера (нужно
   подключать middleware, модифицировать entry). В сложных ситуациях может
   вести себя некорректно.
6. Полуавтоматический code splitting с одним entry файлом и асинхронными
   require с именованными чанками. Вкусно, и не должно составить больших
   трудностей, однако использовать без необходимости не стоит.
7. ES6 modules. Потенциально снижает размер бандла. Делает некомфортной работу
   с sourcemaps из-за переименования переменных.

# Потенциальные проблемы в существующей реализации

- Пустой пароль не захешируется
  - @REFERNCE: Passport::hashPassword
- Из-за одноименного поля для пароля и хеша, обновление паспорта может спровоцировать двойное хеширование пароля
  - @REFERNCE: Passport::beforeUpdate
- Отсутствует next у вызовов passport.authenticate, что может привести к сложноотлаживаемым проблемам
- Сессионная кука sails.sid не просрачивается, поэтому от пляски с remember-me смысла нет
- methodOverride включен, что делает API, возвращающие массивы, небезопасными
- filler выполняется и в продакшене, что оставляет вектор для атаки

# Изменения

+ Изменил usernameField на значение по умолчанию (login -> username)
+ Изменил имя конфига, значение key и имя поля в паспорте для RememberMeStrategy
  + Имя конфига: rememberme -> rememberMe
  + Значение key: token -> app.remember-me
  + Значение поля в паспорте: rememberme -> remember-me
+ Разобрал сервис паспорта на части
  + Логика проверки паспортов: статичные методы модели Passport
  + Инициализация паспорта и стратегий, сериализация и десериализация: bootstrap
  + Логика действий при логине/логауте: AuthController и rememberMe
+ При разлогине уничножаются не все паспорта remember-me, а только текущий (из соответствующей куки)
+ Убрал tryAgain (не актуально для API сервера)
+ Установил длительность сессионной куки sails.sid в один день
- Просроченные паспорта remember-me не считаются валидными

# Chores

- Причесать responses под один формат
  - ok(data, { actions, $context });
  - badRequest(message, data, { actions, $error, $context });
  - serverError(message, data, { actions, $error, $context });
  - forbidden(message, data, { actions, $error, $context });
  - notFound(message, data, { actions, $error, $context });
  - @PAYLOAD: { data, error, actions, $error, $context }
- Логирование
- Роли
  - Политики для API
  - Политики для UI

# Не реализовано

- Регистрация
- Логин и по email и по username
- Другие стратегии логина (через провайдеров)

---

## Dev experience
- Bower support (bundle or wiredep-like mechanism)
- Sourcemaps
- Hot-reload

## Production
- CSS extraction
- Minification

## Postponed
- CORS
- Internationalization
- SEO (description, canonical, meta)
- HTML caching
- Streaming SSR
- Asset caching
