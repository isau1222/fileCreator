# Цель

Более тесная интеграция Vue с Sails. Роутинг без перезагрузки с пререндерингом
на сервере и человеческими URL.

# Рассуждение

1. Мы используем клиентскую шаблонизацию и клиентский роутер,
   поэтому чтобы избежать дублирования кода, мы не будем использовать
   контроллеры, шаблонизацию и роутер sails для страниц приложения,
   а будем использовать их только для API. Но отказываясь от контроллеров,
   мы также отказываемся от постраничных политик и responses. Также,
   используя клиентский роутер, мы теряем возможность указывать статус коды.
2. Чтобы сохранить статус коды и постраничные политики, нужно полноценное SSR,
   с переносом соответствующей логики в клиетский код и возможностью определить
   результат на этапе SSR. Это также предоставит возможности для SEO
   (что потребует механизма управления head в рантайме) и кеширования HTML.
3. Для сборки third-party ассетов (bower_components, библиотеки не из npm,
   шаблоны) мы будем использовать вебпак, потому что он выполняет 100% задач,
   возникающих при этом:
   - Полуавтоматическое подключение ассетов
     - Для bower_components -- автоматически в порядке зависимостей
     - Для остального -- полуавтоматически с помощью glob паттернов
     - Для всего вместе -- возможность программной фильтрации и сортировки
   - Копирование картинок и шрифтов
   - Конкатенация и минификация ассетов с коррекцией путей до картинок и шрифтов

# Ограничения

1. SSR требует префетчинга данных, что требует аутентификации/авторизации
   на стороне сервера. Это ограничивает возможные стратегии
   аутентификации/авторизации (например через кроссдоменные куки).
2. Все состояние, необходимое для пререндеринга, должно быть либо синхронным
   на уровне компонентов (data, props, computed), либо находится в сторе.
   2.1. Не существуют адекватного способа передать локальное состояние
        инстансов с сервера на клиент.
   2.2. Асинхронные действия в процессе пререндеринга отследить невозможно.
   2.3. Не стоит полагаться на хуки для манипуляции состоянием, важным
       для пререндеринга.
3. Поскольку один и тот же код будет исполняться на клиенте и на сервере,
   код, который не расчитан на такое (читай jQuery плагины, завязанные на DOM
   библиотеки, svg и canvas библиотеки) невозможно пререндерить,
   и он должен быть изолирован с помощью проверки окружения и условных require.
4. Поскольку html может отдаваться с разных адресов (напр. `/webapp` и
   `/webapp/dashboard`), ссылки на ассеты (скрипты, стили, изображения) должны
   быть либо абсолютные, либо генерироваться при пререндеринге и в рантайме,
   либо полагаться на указывающий на корень `<base>`.

# Нерешенные проблемы

1. Если в процессе пререндеринга произошла рантайм ошибка, то стек ошибки
   будет неинформативный, поскольку не учитывается sourcemap. Можно попробовать
   "перевести" стек вручную. Релевантно:
   - [https://github.com/vuejs/vue/issues/4376]
   - [https://github.com/nodejs/node/issues/8042]
   - [https://github.com/nodejs/node/issues/6471]
   - [https://github.com/vuejs/vue/pull/4558]
2. В development режиме сервер будет отвечать ошибкой в процессе сборки и
   при неуспешной сборке. Можно исправить, обернув в промисы, но это несколько
   усложнит код, и возможно не стоит того.
3. Если среди ассетов нет css файлов, то собранный css файл будет отсутсвовать,
   хоть и все равно будет требоваться из html. По уму нужно сохранять статы
   бандлов и подключать их, чтобы избежать ручного указания путей и запросов
   к отсутствующим файлам.
4. Добится автоматической пересборки бандла с ассетами проблематично, потому
   что существует много способов произвести изменения требующие пересборки,
   включая изменение файлов, добавление и удаление файлов, изменение bower.json.
   Отсутствия механизма отслеживания зависимостей также не добавляет
   удовольствия. Поэтому ассеты сейчас собираются только при запуске сервера.
5. С сорцмапами имеются проблемы:
   - Экстрактор CSS оставляет за собой пустые модули, у которых есть левые
     сорцмапы.
   - UglifyJS ломает сорцмапы при минификации, так что собрать минифицированный
     билд с сорцмапами не получается.
   - SFC оставляют за собой по несколько сорцмапов.
   - Сорцмапы SFC без стилей попадают в корень вместо правильной директории.


# Дополнительные функции

1. Алиасы. Вкусно, и не должно составить больших трудностей.
2. ES6 language features. Вкусно, и не должно составить больших трудностей.
3. Hot-reload. Упрощает разработку, позволяя обновлять шаблоны и стили
   без перезагрузки страницы. Требует SFC. Усложняет код сервера (нужно
   подключать middleware, модифицировать entry). В сложных ситуациях может
   вести себя некорректно.
4. Полуавтоматический code splitting с одним entry файлом и асинхронными
   require с именованными чанками. Вкусно, и не должно составить больших
   трудностей, однако использовать без необходимости не стоит.
5. Кеширование HTML. В некоторых ситуациях полезно, однако использовать
   без необходимости не стоит.
6. ES6 modules. Потенциально снижает размер бандла. Делает некомфортной работу
   с sourcemaps из-за переименования переменных.

# Изменения

+ Изменил usernameField на значение по умолчанию (login -> username)
+ Изменил имя конфига, значение key и имя поля в паспорте для RememberMeStrategy
  + Имя конфига: rememberme -> rememberMe
  + Значение key: token -> app.remember-me
  + Значение поля в паспорте: rememberme -> remember-me
+ Разобрал сервис паспорта на части
  + Логика проверки паспортов: статичные методы модели Passport
  + Инициализация паспорта и стратегий, сериализация и десериализация: bootstrap
  + Логика действий при логине/логауте: AuthController и rememberMe
+ При разлогине уничножаются не все паспорта remember-me, а только текущий (из соответствующей куки)
+ Убрал tryAgain (не актуально для API сервера)
+ Установил длительность сессионной куки sails.sid в один день

# Chores

- Кеширование ассетов
- Логирование
- Роли
  - Политики для API
  - Политики для UI
- Локализация
- Генерация СЕО-информации роутером

# Не реализовано

- Регистрация
- Логин и по email и по username
- Другие стратегии логина (через провайдеров)
- CORS
- Streaming SSR
